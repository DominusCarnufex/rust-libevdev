---
subtitle: Chapitre 2 &mdash; Prendre ses distances avec C
navtitle: Chapitre 2 &mdash; Prendre ses distances avec C
branch: chapitre2
btnlink: "!BASE_URL!/journal/chapitre-2.rst"
pubdate: 20 août 2016
---

<p>Dans ce deuxième chapitre, nous n’allons pas ajouter de nouvelle fonctionnalité à notre programme : à l’issue de ce chapitre, il se contentera toujours d’afficher la même ligne qu’avant. Cependant, le code sera nettement différent, car il fera appel à plusieurs des outils de Rust pour avoir un code plus propre et plus sûr.</p>
<div class="contents topic" id="sommaire">
<p class="topic-title first">Sommaire</p>
<ul class="simple">
<li><a class="reference internal" href="#meme-c-le-fait" id="id2">Même C le fait</a></li>
<li><a class="reference internal" href="#des-fonctions-des-fonctions-partout" id="id3">Des fonctions… Des fonctions partout…</a></li>
<li><a class="reference internal" href="#la-protection-de-nos-valeurs" id="id4">La protection de nos valeurs</a></li>
</ul>
</div>
<h1 id="meme-c-le-fait">Même C le fait</h1>
<p>La sécurité minimale que peut offrir un programme, c’est de vérifier si la valeur de retour d’une fonction correspond à ce qui était attendu. Le code d’exemple en C le fait ici.</p>
<pre class="code c literal-block">
<span class="name">rc</span> <span class="operator">=</span> <span class="name">libevdev_new_from_fd</span><span class="punctuation">(</span><span class="name">fd</span><span class="punctuation">,</span> <span class="operator">&amp;</span><span class="name">dev</span><span class="punctuation">);</span>
<span class="keyword">if</span> <span class="punctuation">(</span><span class="name">rc</span> <span class="operator">&lt;</span> <span class="literal number integer">0</span><span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="name">fprintf</span><span class="punctuation">(</span><span class="name">stderr</span><span class="punctuation">,</span> <span class="literal string">&quot;Failed to init libevdev (%s)</span><span class="literal string escape">\n</span><span class="literal string">&quot;</span><span class="punctuation">,</span> <span class="name">strerror</span><span class="punctuation">(</span><span class="operator">-</span><span class="name">rc</span><span class="punctuation">));</span>
    <span class="name">exit</span><span class="punctuation">(</span><span class="literal number integer">1</span><span class="punctuation">);</span>
<span class="punctuation">}</span>
</pre>
<p>De manière plus surprenante, il ne vérifie pas que la fonction <code>open</code> a fonctionné correctement. En revanche, le code de libevdev vérifie bien que chaque IOCTL a bien tourné, comme ici, pour le cas qui nous intéresse.</p>
<pre class="code c literal-block">
<span class="name">rc</span> <span class="operator">=</span> <span class="name">ioctl</span><span class="punctuation">(</span><span class="name">fd</span><span class="punctuation">,</span> <span class="name">EVIOCGID</span><span class="punctuation">,</span> <span class="operator">&amp;</span><span class="name">dev</span><span class="operator">-&gt;</span><span class="name">ids</span><span class="punctuation">);</span>
<span class="keyword">if</span> <span class="punctuation">(</span><span class="name">rc</span> <span class="operator">&lt;</span> <span class="literal number integer">0</span><span class="punctuation">)</span>
        <span class="keyword">goto</span> <span class="name">out</span><span class="punctuation">;</span>
</pre>
<p>Le moins que l’on puisse faire est d’effectuer la même vérification dans notre code Rust. Et la bonne nouvelle, c’est que la syntaxe pour un bloc conditionnel est quasiment identique en Rust et en C.</p>
<pre class="code rust literal-block">
<span class="keyword">if</span><span class="whitespace"> </span><span class="ajout">&lt;cond&gt;</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">

</span><span class="punctuation">}</span><span class="whitespace"> </span><span class="keyword">else</span><span class="whitespace"> </span><span class="keyword">if</span><span class="whitespace"> </span><span class="ajout">&lt;cond&gt;</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">

</span><span class="punctuation">}</span><span class="whitespace"> </span><span class="keyword">else</span><span class="whitespace">  </span><span class="punctuation">{</span><span class="whitespace">

</span><span class="punctuation">}</span>
</pre>
<p>Les accolades sont naturellement obligatoires, mais contrairement à C, Rust ne met pas de parenthèses autour de ses conditions. Rust utilise également les même opérateurs de comparaison (<code>==</code>, <code>!=</code>, <code>&lt;</code>, etc.) et de combinaison de conditions (<code>&amp;&amp;</code> et <code>||</code>) que C, vous ne serez pas dépaysés.</p>
<p>La question qui demeure, c’est : que mettre dans ce bloc conditionnel ? Rust est très pratique de ce point de vue-là. En effet, il existe une macro <code>panic</code> qui fonctionne exactement comme <code>println</code>, à ceci près que le programme abandonne en affichant le message d’erreur.</p>
<p>Ainsi, si on ajoute les quelques lignes suivantes après l’ouverture du fichier…</p>
<pre class="code rust literal-block">
<span class="keyword">if</span><span class="whitespace"> </span><span class="name">fd</span><span class="whitespace"> </span><span class="operator">&lt;</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">panic</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;Impossible d’ouvrir le fichier {}.&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>… on obtient le résultat suivant quand on tente de lancer le programme sans les droits d’administrateur.</p>
<pre class="code console literal-block">
<span class="generic output">thread 'main' panicked at 'Impossible d’ouvrir le fichier /dev/input/event6.', libevdev.rs:21
note: Run with `RUST_BACKTRACE=1` for a backtrace.</span>
</pre>
<p>La fonction <code>ioctl</code> fonctionne sur le même modèle que <code>open</code>, et renvoie <code>-1</code> en cas d’échec. Je vous laisse donc implémenter la vérification vous-mêmes. Pour tester et voir si votre code fonctionne, passez <code>0</code> comme argument de l’IOCTL à la place de <code>0x80084502</code>.</p>
<p>Mais le système d’erreur des fonctions C ne se limite pas à renvoyer <code>-1</code> en cas de problème. Il existe une variable <code>errno</code> accessible globalement et qui contient un code correspondant à la dernière erreur rencontrée. Seulement, Rust ne permet pas d’y accéder directement.</p>
<p>Il y a dans le <em>crate</em> <code>libc</code> une fonction <code>__errno_location()</code> qui renvoie un pointeur vers l’endroit où se trouve <code>errno</code>. Vous commencez à avoir l’habitude, cette fonction est <code>unsafe</code>. En outre, comme elle renvoie un pointeur, il faut déréférencer ce dernier pour obtenir la valeur. Ce qui est aussi <code>unsafe</code>, et ce fait au moyen de l’opérateur <code>*</code>, comme on pouvait s’y attendre.</p>
<p>Voici donc une version légèrement plus complète de notre bloc de vérification pour <code>open</code>.</p>
<pre class="code rust literal-block">
<span class="keyword">if</span><span class="whitespace"> </span><span class="name">fd</span><span class="whitespace"> </span><span class="operator">&lt;</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">panic</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;Impossible d’ouvrir le fichier {} (errno = 0x{:x}).&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="keyword">unsafe</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="operator">*</span><span class="name">libc</span><span class="operator">::</span><span class="name">__errno_location</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="punctuation">});</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Cette fois, si vous lancez le programme sans droits d’administrateur, vous obtenez le résultat suivant.</p>
<pre class="code console literal-block">
<span class="generic output">thread 'main' panicked at 'Impossible d’ouvrir le fichier /dev/input/event6 (errno = 0xd).', libevdev.rs:21
note: Run with `RUST_BACKTRACE=1` for a backtrace.</span>
</pre>
<p>L’erreur <code>0xd</code>, c’est <code>EACCESS</code>, ce qui ne vous surprendra pas. En l’état, cependant, ce n’est pas très évident au premier abord. On pourrait ajouter un traitement avec <code>strerror</code>, mais la vérité, c’est que les messages d’erreur renvoyés ne sont absolument pas informatifs.</p>
<p>On va donc plutôt mettre cela dans un coin, et saisir l’occasion d’en apprendre un peu plus sur les fonctions Rust. Vous connaissez déjà la fonction <code>main</code>, qui ne prend aucun argument et ne renvoie rien. Ici, nous allons voir comment renvoyer un argument.</p>
<p>La première chose à faire, c’est de fournir le type de la valeur de retour dans la définition de la fonction. C’est à dire que, entre la parenthèse fermante et l’accolade ouvrante, on va ajouter <code>-&gt;</code> suivi du type de retour. Comme ceci.</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">errno</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="name">c_int</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">unimplemented</span><span class="operator">!</span><span class="punctuation">();</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Notez la macro <code>unimplemented</code> : elle permet que votre programme compile même si vous n’avez pas encore terminé d’implémenter le corps d’une fonction. En revanche, si vous tentez de l’exécuter, vous aurez une erreur.</p>
<p>La deuxième étape, c’est de renvoyer la bonne valeur. Comme en C, le mot-clé <code>return</code> permet de faire exactement cela.</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">errno</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="name">c_int</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword">return</span><span class="whitespace"> </span><span class="keyword">unsafe</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="operator">*</span><span class="name">libc</span><span class="operator">::</span><span class="name">__errno_location</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="punctuation">};</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Mais ce n’est pas la manière idiomatique de faire. En effet, si dans un bloc la dernière instruction <em>n’est pas</em> terminée par un point-virgule, alors cette instruction représente la valeur de retour de ce bloc. C’est notamment le cas avec les fonctions : le code suivant est parfaitement équivalent au précédent.</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">errno</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="name">c_int</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword">unsafe</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="operator">*</span><span class="name">libc</span><span class="operator">::</span><span class="name">__errno_location</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="punctuation">}</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Vous pouvez dès lors appeler <code>errno()</code> dans votre message de panique. Ce que nous n’allons pas faire, parce que cela n’apporte aucune information pertinente. Mais si l’on n’utilise pas la fonction, rustc râle.</p>
<pre class="code console literal-block">
<span class="generic output">warning: function is never used: `errno`, #[warn(dead_code)] on by default</span>
</pre>
<p>Le moyen de faire taire rustc, c’est d’ajouter <code>#[allow(dead_code)]</code> immédiatement avant la définition de la fonction incriminée (cela marche aussi avec les structures et autres définitions de types que nous verrons plus tard). Une autre manière de faire (et qui fonctionne avec absolument tous les identifiants), c’est d’ajouter un <code>_</code> au début du nom de la fonction (<code>_errno()</code>).</p>
<p>Enfin, si vous ajoutez <code>#![allow(dead_code)]</code> (notez le point d’exclamation) au tout début de votre code, vous ne recevrez plus <em>aucun</em> avertissement de ce type. C’est rarement une bonne idée.</p>
<p>En guise de conclusion à cette section, je vous donne un petit exercice. Écrivez une fonction <code>new_input_id</code> qui renvoie un <code>InputId</code> initialisé à 0 partout, et utilisez-la dans le code de <code>main</code>. La définition de la fonction est juste en-dessous, attendez avant de regarder.</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">new_input_id</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="name">InputId</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">InputId</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
            </span><span class="name">bustype</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="name">vendor</span><span class="whitespace">  </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="name">product</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="name">version</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<h1 id="des-fonctions-des-fonctions-partout">Des fonctions… Des fonctions partout…</h1>
<p>Il est temps de passer à la vitesse supérieure, et d’avoir des fonctions qui peuvent prendre des arguments. Vous vous souvenez de la syntaxe <code>&lt;identifiant&gt; : &lt;type&gt;</code> utilisée dans les déclarations de variable ? Eh bien elle sert aussi pour déclarer les arguments d’une fonction. Voici par exemple une fonction qui prend deux entiers non signés de 32 bits et renvoie la somme de leurs carrés.</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">inutile</span><span class="punctuation">(</span><span class="name">a</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u32</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">b</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u32</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="keyword type">u32</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">a</span><span class="whitespace"> </span><span class="operator">*</span><span class="whitespace"> </span><span class="name">a</span><span class="whitespace"> </span><span class="operator">+</span><span class="whitespace"> </span><span class="name">b</span><span class="whitespace"> </span><span class="operator">*</span><span class="whitespace"> </span><span class="name">b</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<div class="note">
<p class="first admonition-title"></p>
<p>Comme cela devient pénible d’écrire «&nbsp;entiers non signés de 32 bits&nbsp;» à chaque fois, voici une liste des types numériques de Rust.</p>
<ul class="simple">
<li>Entiers signés : <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>.</li>
<li>Entiers non signés : <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>.</li>
<li>Flottants : <code>f32</code>, <code>f64</code>.</li>
</ul>
<p class="last">Les types <code>isize</code> et <code>usize</code> ont une taille différente selon la plate-forme : ils ont la taille nécessaire pour contenir un pointeur.</p>
</div>
<p>Ceci étant dit, la question du passage d’arguments à une fonction est moins triviale qu’il n’y paraît. En effet, Rust applique une sémantique de déplacement à toutes les liaisons de variable. Prenez le code suivant.</p>
<pre class="code rust literal-block">
<span class="keyword">struct</span><span class="whitespace"> </span><span class="name">Point</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u16</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u16</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">main</span><span class="punctuation">()</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">p1</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">Point</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">42</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">79</span><span class="whitespace"> </span><span class="punctuation">};</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">p2</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">p1</span><span class="punctuation">;</span><span class="whitespace">

    </span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;({}, {})&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p1</span><span class="punctuation">.</span><span class="name">x</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p1</span><span class="punctuation">.</span><span class="name">y</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Si vous essayez de le compiler, vous obtiendrez la double erreur suivante.</p>
<pre class="code console literal-block">
<span class="generic output">error[E0382]: use of moved value: `p1.x`
error[E0382]: use of moved value: `p1.y`</span>
</pre>
<p>Cela vient du fait qu’à tout moment, il ne peut y avoir qu’un et un seul identifiant associé à une donnée particulière. Ainsi, la première ligne de <code>main</code> associe l’identifiant <code>p1</code> à la donnée <code>Point { x : 42, y : 79 }</code>. Puis la seconde ligne associe <code>p2</code> à cette même donnée, et coupe la liaison entre elle et <code>p1</code>. Si bien qu’arrivés à la quatrième ligne, <code>p1</code> n’est plus associé à aucune donnée, et tenter d’accéder à un de ses champs ne peut rien donner de bon.</p>
<p>Pour placer un peu de vocabulaire, on dit qu’une variable a la <strong>propriété</strong> d’une donnée lorsque ladite donnée et l’identifiant de la variable sont liés, et l’on dit que l’on <strong>déplace</strong> (<em>move</em>) la valeur lorsque l’on transfère sa propriété d’une variable à une autre.</p>
<p>Cette construction, qui peut paraître pénible au premier abord, poursuit plusieurs objectifs.</p>
<p>Premièrement, à tout moment, le compilateur sait quelle variable est propriétaire de quelle donnée. Cela signifie que lorsque cette variable n’est plus utilisée (par exemple, parce qu’on arrive au bout de la fonction où elle a été définie), le compilateur peut supprimer la donnée sans risque. On limite ainsi fortement les fuites de mémoire.</p>
<p>Mais surtout, contrairement à la plupart des langages, cette vérification de la durée de vie des données est réalisée à la compilation et non à l’exécution, ce qui permet de se passer d’un ramasse-miettes, et ainsi d’accélérer sensiblement l’exécution.</p>
<p>Deuxièmement, cela facilite l’écriture de programmes parallélisés, car une même donnée ne peut pas être utilisée par deux fils d’exécution à la fois : un seul de ces fils en a la propriété, et s’il transmet la donnée à un autre fil, il ne peut plus s’en servir lui-même.</p>
<p>Mais revenons-en à nos fonctions. Lorsque l’on passe une valeur en argument d’une fonction, on crée une liaison entre la valeur et l’argument, et la valeur n’est plus accessible dans la fonction appelante. Le code suivant ne compilera pas non plus, et avec les mêmes erreurs.</p>
<pre class="code rust literal-block">
<span class="keyword">struct</span><span class="whitespace"> </span><span class="name">Point</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u16</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u16</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">affiche</span><span class="punctuation">(</span><span class="name">p</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">Point</span><span class="punctuation">)</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;({}, {})&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p</span><span class="punctuation">.</span><span class="name">x</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p</span><span class="punctuation">.</span><span class="name">y</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">main</span><span class="punctuation">()</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">p1</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">Point</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">42</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">79</span><span class="whitespace"> </span><span class="punctuation">};</span><span class="whitespace">

    </span><span class="name">affiche</span><span class="punctuation">(</span><span class="name">p1</span><span class="punctuation">);</span><span class="whitespace">

    </span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;({}, {})&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p1</span><span class="punctuation">.</span><span class="name">x</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p1</span><span class="punctuation">.</span><span class="name">y</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Il faudrait que la fonction appelée rende à la fonction appelante la propriété de ces données en les renvoyant, comme ceci.</p>
<pre class="code rust literal-block">
<span class="keyword">struct</span><span class="whitespace"> </span><span class="name">Point</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u16</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u16</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">affiche</span><span class="punctuation">(</span><span class="name">p</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">Point</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="name">Point</span><span class="whitespace">  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;({}, {})&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p</span><span class="punctuation">.</span><span class="name">x</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p</span><span class="punctuation">.</span><span class="name">y</span><span class="punctuation">);</span><span class="whitespace">
    </span><span class="name">p</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">main</span><span class="punctuation">()</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">p1</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">Point</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">42</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">79</span><span class="whitespace"> </span><span class="punctuation">};</span><span class="whitespace">

    </span><span class="name">p1</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">affiche</span><span class="punctuation">(</span><span class="name">p1</span><span class="punctuation">);</span><span class="whitespace">

    </span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;({}, {})&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p1</span><span class="punctuation">.</span><span class="name">x</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p1</span><span class="punctuation">.</span><span class="name">y</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Mais une telle solution devient très vite très pénible, outre qu’elle nous oblige à rendre <code>p1</code> mutable pour qu’il puisse récupérer sa propre valeur. C’est pourquoi Rust permet de passer une variable par <strong>référence</strong>, ce qui s’appelle <strong>emprunter</strong> la variable.</p>
<p>Une référence est signalée par la présence de <code>&amp;</code> au début de l’identifiant du type ou de la variable. Elle a précisément pour caractéristique de <em>ne pas</em> prendre la propriété de la donnée concernée. Voici donc un code légèrement modifié, pour que notre fonction se contente d’emprunter la variable.</p>
<pre class="code rust literal-block">
<span class="keyword">struct</span><span class="whitespace"> </span><span class="name">Point</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u16</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u16</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">affiche</span><span class="punctuation">(</span><span class="name">p</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="name">Point</span><span class="punctuation">)</span><span class="whitespace">  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;({}, {})&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p</span><span class="punctuation">.</span><span class="name">x</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p</span><span class="punctuation">.</span><span class="name">y</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">main</span><span class="punctuation">()</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">p1</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">Point</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">42</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">79</span><span class="whitespace"> </span><span class="punctuation">};</span><span class="whitespace">

    </span><span class="name">affiche</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name">p1</span><span class="punctuation">);</span><span class="whitespace">

    </span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;({}, {})&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p1</span><span class="punctuation">.</span><span class="name">x</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p1</span><span class="punctuation">.</span><span class="name">y</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Naturellement, lorsqu’une valeur a été empruntée, il est interdit de réaliser sur elle une quelconque action qui nécessite d’en transférer la propriété. Le code suivant, par exemple, ne compilera pas.</p>
<pre class="code rust literal-block">
<span class="keyword">struct</span><span class="whitespace"> </span><span class="name">Point</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u16</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u16</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">affiche</span><span class="punctuation">(</span><span class="name">p</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">Point</span><span class="punctuation">)</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;({}, {})&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p</span><span class="punctuation">.</span><span class="name">x</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p</span><span class="punctuation">.</span><span class="name">y</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">main</span><span class="punctuation">()</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">p1</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">Point</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">42</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">79</span><span class="whitespace"> </span><span class="punctuation">};</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">p2</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="name">p1</span><span class="punctuation">;</span><span class="whitespace">

    </span><span class="name">affiche</span><span class="punctuation">(</span><span class="name">p1</span><span class="punctuation">);</span><span class="whitespace">

    </span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;({}, {})&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p2</span><span class="punctuation">.</span><span class="name">x</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">p2</span><span class="punctuation">.</span><span class="name">y</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>En effet, <code>affiche</code> tente de prendre la propriété de la valeur liée à <code>p1</code> alors qu’elle est empruntée par <code>p2</code>, et qu’elle le reste jusqu’à la disparition de <code>p2</code>, à la fin du bloc.</p>
<div class="note" id="copy">
<p class="first admonition-title"></p>
<p class="last">Vous aurez remarqué que tous les exemples utilisent une structure <code>Point</code> plutôt que quelque chose de plus simple, comme un <code>u32</code>. C’est qu’il existe un mécanisme, que nous verrons plus tard, qui permet de demander que les valeurs d’un type donné soient copiées plutôt que déplacées. Et notamment, tous les types numériques natifs ont cette propriété, de même que les pointeurs nus.</p>
</div>
<p>Il reste encore quelques petites choses à voir pour comprendre comment fonctionnent les références et ne pas se retrouver face à des erreurs de compilation cryptique.</p>
<p>La première, c’est qu’une référence a une <strong>durée de vie</strong>, c’est-à-dire une portion du code dans laquelle elle est valide et pointe de manière certaine vers des données qui existent, et cette durée de vie ne peut naturellement pas être supérieure à celle des données elles-mêmes. Prenez l’exemple suivant.</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">main</span><span class="punctuation">()</span><span class="whitespace">   </span><span class="punctuation">}</span><span class="whitespace">

    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword type">i32</span><span class="punctuation">;</span><span class="whitespace">

    </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="literal number integer">42</span><span class="punctuation">;</span><span class="whitespace">
        </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="name">x</span><span class="punctuation">;</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">

    </span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;{}&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">y</span><span class="punctuation">);</span><span class="whitespace">

</span><span class="punctuation">}</span>
</pre>
<p>La compilation échoue avec le message d’erreur suivant.</p>
<pre class="code console literal-block">
<span class="generic output">error: `x` does not live long enough</span>
</pre>
<p>En effet, <code>x</code> est déclarée entre les accolades, et disparaît donc à la fin de ce bloc. Ce qui fait qu’au moment de l’appel à <code>println</code>, <code>y</code> pointe vers des données qui n’existent plus, et le compilateur ne le permet pas.</p>
<div class="important">
<p class="first admonition-title"></p>
<p class="last">Les variables sont supprimées dans l’ordre inverse de celui où elles ont été créées. Cela signifie que si vous créez une variable de type référence avant la variable sur laquelle elle va pointer, vous obtiendrez la même erreur que ci-dessus.</p>
</div>
<p>La deuxième chose, c’est qu’il est possible de demander qu’un argument soit mutable dans la fonction : il suffit de placer le mot-clé <code>mut</code> avant son nom. De la même manière, on peut emprunter une valeur dans l’optique de la modifier, au moyen d’une référence mutable (<code>&amp;mut &lt;identifiant&gt;</code>). Évidemment, la variable de départ doit être mutable, sinon, ce serait trop facile.</p>
<p>Il y a cependant une règle très importante. <strong>Dans un même bloc, il ne peut exister qu’une seule référence mutable à une même valeur, et des références mutables et non mutables ne peuvent cohabiter.</strong> Par exemple, le code suivant refuse de compiler (<code>println</code> utilise des références non mutables en sous-main).</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="literal number integer">42</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">x</span><span class="punctuation">;</span><span class="whitespace">

</span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;{}&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">x</span><span class="punctuation">);</span>
</pre>
<p>Pour que le code compile, il faut s’assurer que la référence mutable ait disparu avant toute utilisation d’une référence non mutable, ce qui peut se faire en la mettant dans un bloc créé pour l’occasion.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="literal number integer">42</span><span class="punctuation">;</span><span class="whitespace">

</span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">x</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;{}&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">x</span><span class="punctuation">);</span>
</pre>
<p>Là aussi, cela peut sembler pénible, mais cela permet de paralléliser des programmes en s’assurant qu’une donnée ne sera pas modifiée par un fil d’exécution essaye de la lire. Ou que l’on ne va pas ajouter des éléments à un tableau que l’on est en train de parcourir. Etc.</p>
<p>Le troisième point, c’est qu’une référence peut être déréférencée afin d’accéder à la valeur pointée, au moyen du même opérateur <code>*</code> que pour les pointeurs nus. Voyez par exemple ce code, qui permet de modifier <code>x</code> par le biais de sa référence <code>y</code>.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">x</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="literal number integer">40</span><span class="punctuation">;</span><span class="whitespace">

</span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">y</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">x</span><span class="punctuation">;</span><span class="whitespace">
    </span><span class="operator">*</span><span class="name">y</span><span class="whitespace"> </span><span class="operator">+=</span><span class="whitespace"> </span><span class="literal number integer">2</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;{}&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">x</span><span class="punctuation">);</span>
</pre>
<p>Voilà, cela fait beaucoup d’informations d’un coup, et il reste encore beaucoup à dire, notamment sur les durées de vie. Mais il est indispensable de bien comprendre ces mécanismes de propriété et d’emprunt pour ne pas s’arracher les cheveux sur des erreurs en apparence incompréhensibles, et ils sont indissociables les uns des autres.</p>
<p>Pour terminer en douceur par un petit exercice, vous allez écrire une fonction qui prend un <code>String</code> et le transforme en chaîne de caractères C (<code>*const c_char</code>), et l’utiliser à la place des premières lignes de la fonction <code>main</code>. Comme d’habitude, la solution est en-dessous, mais prenez le temps de réféléchir.</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">to_c_string</span><span class="punctuation">(</span><span class="name">st</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name builtin">String</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword reserved">const</span><span class="whitespace"> </span><span class="name">c_char</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">st</span><span class="punctuation">.</span><span class="name">push</span><span class="punctuation">(</span><span class="literal string char">'\0'</span><span class="punctuation">);</span><span class="whitespace">
    </span><span class="name">st</span><span class="punctuation">.</span><span class="name">as_ptr</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword reserved">const</span><span class="whitespace"> </span><span class="name">c_char</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">main</span><span class="punctuation">()</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">st</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="literal string">&quot;/dev/input/event6&quot;</span><span class="punctuation">.</span><span class="name">to_string</span><span class="punctuation">();</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">pt</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">to_c_string</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">);</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">fd</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="keyword">unsafe</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">open</span><span class="punctuation">(</span><span class="name">pt</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">O_RDONLY</span><span class="whitespace"> </span><span class="operator">|</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">O_NONBLOCK</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="punctuation">};</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<h1 id="la-protection-de-nos-valeurs">La protection de nos valeurs</h1>
<p>Pour terminer ce chapitre, nous allons améliorer le fonctionnement de l’appel à IOCTL. Pour rappel, voici comment il est codé pour l’instant.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">ii</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">InputId</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">bustype</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="name">vendor</span><span class="whitespace">  </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="name">product</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="name">version</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="whitespace">
</span><span class="punctuation">};</span><span class="whitespace">

</span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">io</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="keyword">unsafe</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">libc</span><span class="operator">::</span><span class="name">ioctl</span><span class="punctuation">(</span><span class="name">fd</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="literal number hex">0x80084502</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="name">c_ulong</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">ii</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">_</span><span class="punctuation">)</span><span class="whitespace">
</span><span class="punctuation">};</span>
</pre>
<p>Il faut savoir que libdrm définit en son sein une version mieux conçue de <code>ioctl</code>, implémentée comme suit.</p>
<pre class="code c literal-block">
<span class="keyword type">int</span>
<span class="name function">drmIoctl</span><span class="punctuation">(</span><span class="keyword type">int</span> <span class="name">fd</span><span class="punctuation">,</span> <span class="keyword type">unsigned</span> <span class="keyword type">long</span> <span class="name">request</span><span class="punctuation">,</span> <span class="keyword type">void</span> <span class="operator">*</span><span class="name">arg</span><span class="punctuation">)</span>
<span class="punctuation">{</span>
    <span class="keyword type">int</span>     <span class="name">ret</span><span class="punctuation">;</span>

    <span class="keyword">do</span> <span class="punctuation">{</span>
        <span class="name">ret</span> <span class="operator">=</span> <span class="name">ioctl</span><span class="punctuation">(</span><span class="name">fd</span><span class="punctuation">,</span> <span class="name">request</span><span class="punctuation">,</span> <span class="name">arg</span><span class="punctuation">);</span>
    <span class="punctuation">}</span> <span class="keyword">while</span> <span class="punctuation">(</span><span class="name">ret</span> <span class="operator">==</span> <span class="operator">-</span><span class="literal number integer">1</span> <span class="operator">&amp;&amp;</span> <span class="punctuation">(</span><span class="name">errno</span> <span class="operator">==</span> <span class="name">EINTR</span> <span class="operator">||</span> <span class="name">errno</span> <span class="operator">==</span> <span class="name">EAGAIN</span><span class="punctuation">));</span>
    <span class="keyword">return</span> <span class="name">ret</span><span class="punctuation">;</span>
<span class="punctuation">}</span>
</pre>
<p>Il peut arriver qu’un IOCTL échoue (donc renvoie <code>-1</code>) sans qu’il y ait <em>réellement</em> eu d’erreur avec l’appel. Cela se produit dans deux cas.</p>
<ul class="simple">
<li>Lorsque le processus à reçu un signal (comme <code>SIGINT</code>, <code>SIGTERM</code>, ou d’autres moins nocifs comme <code>SIGALRM</code>), qu’il a dû traiter, avant de reprendre son excution normale. Cela met généralement la pagaille dans l’IOCTL, et celui-ci préfère laisser tomber avec l’erreur <code>EINTR</code> (pour <em>interruption</em>).</li>
<li>Lorsque le périphérique est occupé et qu’il faut recommencer plus tard, l’erreur étant alors <code>EAGAIN</code>.</li>
</ul>
<p>Cette version améliorée de l’appel recommence donc l’IOCTL tant que l’une de ces deux situations est rencontrée, et n’abandonne que si une véritable erreur est rencontrée.</p>
<p>Pour l’implémenter en Rust, il va nous falloir des boucles. Malheureusement, la boucle <code>do</code>-<code>while</code> n’existe pas en Rust. Voici donc un ersatz un peu ridicule, mais qui fait le travail.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">ret</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">c_int</span><span class="punctuation">;</span><span class="whitespace">

</span><span class="keyword">loop</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">ret</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="keyword">unsafe</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">ioctl</span><span class="punctuation">(</span><span class="name">fd</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="literal number hex">0x80084502</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="name">c_ulong</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">ii</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">_</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="punctuation">};</span><span class="whitespace">
    </span><span class="keyword">if</span><span class="whitespace"> </span><span class="name">ret</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="operator">-</span><span class="literal number integer">1</span><span class="whitespace"> </span><span class="operator">&amp;&amp;</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">errno</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">EINTR</span><span class="whitespace"> </span><span class="operator">||</span><span class="whitespace"> </span><span class="name">errno</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">EAGAIN</span><span class="punctuation">)</span><span class="whitespace">
         </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="keyword">continue</span><span class="punctuation">;</span><span class="whitespace"> </span><span class="punctuation">}</span><span class="whitespace">
    </span><span class="keyword">else</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="keyword">break</span><span class="punctuation">;</span><span class="whitespace">    </span><span class="punctuation">}</span><span class="whitespace"> </span><span class="comment single">// Ersatz moche de do-while.
</span><span class="punctuation">}</span>
</pre>
<p>Les mots-clés <code>break</code> et <code>continue</code> devraient vous être familiers, je n’insiste pas. Quant à <code>loop</code>, il crée une boucle infinie, en toute simplicité. Il existe également des boucles plus classiques, avec la syntaxe <code>while &lt;cond&gt; { … }</code>, toujours sans parenthèses autour de la condition.</p>
<p>Il ne reste plus qu’à mettre tout cela, ainsi que la vérification du bon résultat, dans une fonction <code>ioctl</code>. Aucun risque de collision avec la fonction d’origine, puisque celle-ci a besoin du préfixe <code>libc::</code>. Mais vous allez assez vite rencontrer un problème : le type <code>*mut _</code> n’est pas accepté en argument, il va impérativement falloir spécifier un type explicitement.</p>
<p>Utilisez donc <code>*mut u8</code>, puisque C se fiche de savoir quel type avait le pointeur dans le code Rust qui l’appelle. Ce qui nous donne la fonction ci-dessous (ne regardez pas avant d’avoir essayé par vous-mêmes).</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">ioctl</span><span class="punctuation">(</span><span class="name">fd</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">c_int</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">request</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u32</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">arg</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="keyword type">u8</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="name">c_int</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">ret</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">c_int</span><span class="punctuation">;</span><span class="whitespace">

    </span><span class="keyword">loop</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="name">ret</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="keyword">unsafe</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">ioctl</span><span class="punctuation">(</span><span class="name">fd</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">request</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="name">c_ulong</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">arg</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="punctuation">};</span><span class="whitespace">
        </span><span class="keyword">if</span><span class="whitespace"> </span><span class="name">ret</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="operator">-</span><span class="literal number integer">1</span><span class="whitespace"> </span><span class="operator">&amp;&amp;</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">errno</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">EINTR</span><span class="whitespace"> </span><span class="operator">||</span><span class="whitespace"> </span><span class="name">errno</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">EAGAIN</span><span class="punctuation">)</span><span class="whitespace">
             </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="keyword">continue</span><span class="punctuation">;</span><span class="whitespace"> </span><span class="punctuation">}</span><span class="whitespace">
        </span><span class="keyword">else</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="keyword">break</span><span class="punctuation">;</span><span class="whitespace">    </span><span class="punctuation">}</span><span class="whitespace"> </span><span class="comment single">// Ersatz moche de do-while.
</span><span class="whitespace">    </span><span class="punctuation">}</span><span class="whitespace">

    </span><span class="keyword">if</span><span class="whitespace"> </span><span class="name">ret</span><span class="whitespace"> </span><span class="operator">&lt;</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="name">panic</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;L’IOCTL a échoué.&quot;</span><span class="punctuation">);</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">

    </span><span class="name">ret</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Et l’appel dans <code>main</code> se résume à cette ligne.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">_</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">ioctl</span><span class="punctuation">(</span><span class="name">fd</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="literal number hex">0x80084502</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">ii</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">_</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="keyword type">u8</span><span class="punctuation">);</span>
</pre>
<p>Convertir directement une référence vers un pointeur nu sur un autre type n’est pas autorisé : il faut passer par un pointeur nu non typé intermédiaire, car les conversions entre n’importe quels types de pointeurs nus sont autorisées, par contre. En outre, lier le résultat d’une fonction à <code>_</code> permet de s’en débarrasser sans que rustc ne râle.</p>
<p>Il reste une dernière chose à faire, et l’on pourra s’arrêter là : toutes les valeurs de requête ne donnent pas un IOCTL valide, ce serait plus sécurisé si la fonction n’acceptait que des requêtes valides en argument. Cela est possible en définition une <strong>énumération</strong>, qui ne contiendra donc que les valeurs autorisées.</p>
<p>Pour l’instant, on va se contenter d’une énumération basique, qui suit la syntaxe suivante.</p>
<pre class="code rust literal-block">
<span class="keyword">enum</span><span class="whitespace"> </span><span class="ajout">&lt;identifiant du type&gt;</span><span class="whitespace">  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="ajout">&lt;variante 1&gt;</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="ajout">&lt;variante 2&gt;</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="ajout">&lt;variante 3&gt;</span><span class="punctuation">,</span><span class="whitespace">
    </span>…<span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>L’identifiant du type et le nom des variantes doit être en <em>CamelCase</em>. Il est en outre possible de préciser une valeur numérique associée à une variante donnée, en la faisant suivre de <code>= &lt;nombre&gt;</code>. Voici donc notre type <code>IOCTL</code>, contenant une unique variante.</p>
<pre class="code rust literal-block">
<span class="keyword">enum</span><span class="whitespace"> </span><span class="name">IOCTL</span><span class="whitespace">  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">GetId</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="literal number hex">0x80084502</span><span class="punctuation">,</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>On peut alors modifier le type de notre fonction <code>ioctl</code> pour qu’elle prenne un type <code>IOCTL</code> plutôt qu’un <code>u32</code> : on a alors la garantie que seules des valeurs autorisées pourront être utilisées comme requête. Ne reste plus qu’à modifier l’appel de fonction, comme suit.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">_</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">ioctl</span><span class="punctuation">(</span><span class="name">fd</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">IOCTL</span><span class="operator">::</span><span class="name">GetId</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">ii</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">_</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="keyword type">u8</span><span class="punctuation">);</span>
</pre>
<p>En effet, dans une énumération, l’identifiant de type constitue un espace de noms auquel les identifiants des variantes sont rattachés : de cette manière, deux types peuvent avoir des variantes qui s’appellent pareil (un truc courant, comme <code>None</code>, par exemple) sans qu’elles entrent en conflit. Si vous êtes vraiment sûrs de ce que vous faites, vous pouvez spécifier <code>use &lt;type&gt;::*;</code> pour exporter les variantes dans l’espace de noms général.</p>
<p>Compilez. C’est raté. Le compilateur nous envoie paître en nous explicant que <code>request</code> a été déplacée par <code>libc::ioctl</code> dans une itération précédente de la boucle. Il n’y a rien à faire, aucun moyen de contourner avec des références : on est obligés de passer par le mécanisme dont j’ai parlé <a class="reference internal" href="#copy">plus haut</a> pour que la valeur soit copiée plutôt que déplacée.</p>
<p>Cela se fait en ajoutant la ligne <code>#[derive(Clone, Copy)]</code> avant la définition de notre énumération. Cette solution n’est pas toujours possible, et il est beaucoup trop tôt pour vous expliquer en quoi elle consiste <em>réellement</em>, mais pour l’instant, sachez qu’elle existe.</p>
<hr class="docutils" />
<p>Ce fut encore un long chapitre, avec de nouvelles notions à foison. N’hésitez pas à le relire à tête reposée, et à faire des essais de votre côté jusqu’à ce que vous ayez pleinement intégré le fonctionnement de la propriété et de l’emprunt, car c’est sûrement la notion la plus difficile à maîtriser en Rust, et elle est omniprésente.</p>
