---
subtitle: Chapitre 4 &mdash; Capsule de survie
navtitle: Chapitre 4 &mdash; Capsule de survie
branch: chapitre4
btnlink: "!BASE_URL!/journal/chapitre-4.rst"
pubdate: 26 août 2016
---

<p>À l’heure actuelle, notre code est moche. Il est encombré, lourd par endroits, il y en a des morceaux dans tous les sens sans réelle organisation : ce n’est pas ce que je vous avais vendu en vous parlant de Rust. C’est parce qu’il vous reste encore de nombreux outils du langage à découvrir. Ce chapitre sera similaire au <a class="reference external" href="{{site.baseurl}}/journal/chapitre-2.html">chapitre 2</a> : le code ne fera rien de plus à la fin qu’au début, mais il utilisera beaucoup plus d’outils afin d’être mieux écrit.</p>
<div class="contents topic" id="sommaire">
<p class="topic-title first">Sommaire</p>
<ul class="simple">
<li><a class="reference internal" href="#discours-de-la-methode" id="id2">Discours de la méthode</a></li>
<li><a class="reference internal" href="#deconstructivisme" id="id3">Déconstructivisme</a></li>
<li><a class="reference internal" href="#decor-a-motifs" id="id4">Décor à motifs</a></li>
</ul>
</div>
<h1 id="discours-de-la-methode">Discours de la méthode</h1>
<p>On a vu dans le chapitre 2 que les énumérations constituent un espace de noms dans lequel sont rangées les différentes variantes : toutes les variantes de l’énumération doivent être précédées de <code>MonType::</code>, à moins de les importer dans l’espace de noms général au moyen de <code>use MonType::*;</code>.</p>
<p>Tous les types pleins de Rust constituent un espace de noms, qu’il s’agisse d’énumérations, de structures, ou même des types natifs du langage : ce n’est pas le cas des références et pointeurs nus, en revanche. Et dans cet espace de noms, il est possible de définir des fonctions, à l’aide de la syntaxe ci-dessous.</p>
<pre class="code rust literal-block">
<span class="keyword">impl</span><span class="whitespace"> </span><span class="name">MonType</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">

</span><span class="comment single">// Les définitions de fonction vont ici.
</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Pour appeler ces fonctions membres, il faut utiliser la syntaxe <code>&lt;type&gt;::&lt;fonction&gt;</code>, qui doit commencer à vous être familière, à présent. Naturellement, n’importe quelle fonction peut être définie dans l’espace de noms d’un type ; cependant, il en existe deux sortes particulières, qui sont les plus couramment utilisées car les plus utiles.</p>
<p>La première sorte, ce sont les constructeurs personnalisés : ils renvoient un objet du type dont la fonction est membre, construit à partir des éventuels arguments de la fonction. Prenons un exemple, ce sera plus évident. Rappelez-vous cette fonction.</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">new_input_id</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="name">InputId</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">InputId</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="name">bustype</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">,</span><span class="whitespace">
        </span><span class="name">vendor</span><span class="whitespace">  </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">,</span><span class="whitespace">
        </span><span class="name">product</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">,</span><span class="whitespace">
        </span><span class="name">version</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Il serait beaucoup plus idiomatique de l’écrire ainsi.</p>
<pre class="code rust literal-block">
<span class="keyword">impl</span><span class="whitespace"> </span><span class="name">InputId</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">new</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="name">Self</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="name">InputId</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
            </span><span class="name">bustype</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="name">vendor</span><span class="whitespace">  </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="name">product</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="name">version</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="whitespace">
        </span><span class="punctuation">}</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Notez le type <code>Self</code>, qui permet de remplacer l’identifiant du type que l’on est actuellement en train d’<strong>implémenter</strong>, et ce dans toutes les situations. Sauf quand on veut accéder aux variantes d’une énumération, curieusement. On peut alors modifier la création de l’<code>InputId</code> dans la fonction <code>main</code>.</p>
<pre class="code rust literal-block">
<span class="comment single">// let mut ii = new_input_id();
</span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">ii</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">InputId</span><span class="operator">::</span><span class="name">new</span><span class="punctuation">();</span>
</pre>
<div class="note">
<p class="first admonition-title"></p>
<p class="last">Les constructeurs personnalisés s’opposent aux constructeurs natifs, qui sont ceux fournis par la syntaxe elle-même : <code>InputId { … }</code> pour une structure, <code>EventType::Synchro</code> pour une énumération simple, <code>0x42</code> pour un type natif, etc.</p>
</div>
<p>La deuxième sorte, ce sont les fonctions qui prennent en premier (voire en seul) argument un objet du type implémenté, ou une référence vers ce type. Dans ce cas, dans la signature de type de la fonction membre, on remplace le premier argument par respectivement <code>self</code>, <code>&amp;self</code> et <code>&amp;mut self</code>. Là encore, un exemple sera plus parlant. Rappelez-vous l’appel à l’IOCTL qui suit la construction d’un <code>InputId</code>.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">_</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">ioctl</span><span class="punctuation">(</span><span class="name">fd</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">IOCTL</span><span class="operator">::</span><span class="name">GetId</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">ii</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">_</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="keyword type">u8</span><span class="punctuation">);</span>
</pre>
<p>La partie <code>&amp;mut ii as *mut _ as *mut u8</code> pourrait être remplacée par une fonction qui prend pour seul argument une référence mutable sur un <code>InputId</code>, donc par une fonction membre, que voici.</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">as_mut_ptr</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name builtin pseudo">self</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="keyword type">u8</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name builtin pseudo">self</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">Self</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="keyword type">u8</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Trois choses sont à noter.</p>
<ul class="simple">
<li>Le nom <code>as_mut_ptr</code> est classique. Lorsqu’une fonction membre renvoie une référence vers l’objet concerné, ou plus généralement vers un élément constitutif mais caché de celui-ci, il est d’usage de l’appeler <code>as_ref</code>. De même, <code>as_mut</code> renvoie une référence mutable, <code>as_ptr</code> renvoie un pointeur nu, et <code>as_mut_ptr</code> renvoie un pointeur nu mutable.</li>
<li>Ce n’est pas forcément très intuitif, mais <code>&amp;mut self</code> équivaut à <code>self : &amp;mut InputId</code>. Par conséquent, <code>self</code> est ici une référence mutable, mais dans une fonction de type <code>fonction(self, …)</code>, <code>self</code> serait un <code>InputId</code> et non une référence. Attention donc au type exact du <code>self</code> que vous manipulez.</li>
<li>À nouveau, on utilise <code>Self</code> à la place de l’identifiant du type.</li>
</ul>
<p>L’intérêt principal de cette sorte de fonctions membres, c’est qu’on peut employer la <strong>syntaxe de méthode</strong>, c’est-à-dire la syntaxe <code>&lt;objet&gt;.&lt;fonction&gt;</code> que vous avez déjà rencontrée. Et ce qui est encore mieux, c’est que cette syntaxe se fiche de savoir si <code>&lt;objet&gt;</code> est un objet plein, une référence, ou même une référence de référence de référence : elle trouvera toujours la bonne fonction membre, et passera l’argument sous la bonne forme.</p>
<p>L’appel de l’IOCTL devient par conséquent ceci.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">_</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">ioctl</span><span class="punctuation">(</span><span class="name">fd</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">IOCTL</span><span class="operator">::</span><span class="name">GetId</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">ii</span><span class="punctuation">.</span><span class="name">as_mut_ptr</span><span class="punctuation">());</span>
</pre>
<p>Ce qui est à la fois plus propre et plus clair quant à ce qu’on fait exactement.</p>
<h1 id="deconstructivisme">Déconstructivisme</h1>
<p>Il y a un autre passage de la fonction <code>main</code> qui n’est vraiment pas propre, et qui mériterait qu’on l’améliore. C’est celui-ci.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">st</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="literal string">&quot;/dev/input/event6&quot;</span><span class="punctuation">.</span><span class="name">to_string</span><span class="punctuation">();</span><span class="whitespace">
</span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">pt</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">to_c_string</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">fd</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="keyword">unsafe</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">open</span><span class="punctuation">(</span><span class="name">pt</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">O_RDONLY</span><span class="whitespace"> </span><span class="operator">|</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">O_NONBLOCK</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="punctuation">};</span><span class="whitespace">

</span><span class="keyword">if</span><span class="whitespace"> </span><span class="name">fd</span><span class="whitespace"> </span><span class="operator">&lt;</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">panic</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;Impossible d’ouvrir le fichier {}.&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Et avec la fonction appelée, pour avoir toutes les informations.</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">to_c_string</span><span class="punctuation">(</span><span class="name">st</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name builtin">String</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword reserved">const</span><span class="whitespace"> </span><span class="name">c_char</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">st</span><span class="punctuation">.</span><span class="name">push</span><span class="punctuation">(</span><span class="literal string char">'\0'</span><span class="punctuation">);</span><span class="whitespace">
    </span><span class="name">st</span><span class="punctuation">.</span><span class="name">as_ptr</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword reserved">const</span><span class="whitespace"> </span><span class="name">c_char</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Pour améliorer ce code, nous allons définir un nouveau type, comme ceci.</p>
<pre class="code rust literal-block">
<span class="keyword">struct</span><span class="whitespace"> </span><span class="name">CString</span><span class="punctuation">(</span><span class="name builtin">String</span><span class="punctuation">);</span>
</pre>
<p>Ceci est une structure-tuple, et vous n’en avez encore jamais rencontré. Une structure-tuple est déclarée avec le mot-clé <code>struct</code>, mais contrairement à une structure classique, ses champs ne sont pas nommés : on ne met donc entre parenthèses que les types de ces champs. Ici, il n’y en a qu’un, mais il peut y en avoir plusieurs, comme dans cet exemple.</p>
<pre class="code rust literal-block">
<span class="keyword">struct</span><span class="whitespace"> </span><span class="name">RGBA</span><span class="punctuation">(</span><span class="keyword type">u8</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="keyword type">u8</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="keyword type">u8</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="keyword type">u8</span><span class="punctuation">);</span>
</pre>
<p>Quel est intérêt d’une telle structure, sachant qu’on ne disposera pas de champs nommés pour accéder aux données ? Il est assez spécifique, et c’est pour cela que vous ne rencontrerez pas beaucoup de structures-tuples. Il existe en Rust la possibilité de définir un synonyme de type, à l’aide du mot clé <code>type</code>. Voici par exemple comment le type <code>c_int</code> est défini.</p>
<pre class="code rust literal-block">
<span class="keyword">type</span><span class="whitespace"> </span><span class="name">c_int</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="keyword type">i32</span><span class="punctuation">;</span>
</pre>
<p>Les deux types sont véritablement synonymes : le compilateur ne fait aucune différence entre les deux, vous pouvez les employer l’un à la place de l’autre sans souci, c’est un pur confort d’écriture.</p>
<p>Seulement, il est interdit en Rust de définir des fonctions membres pour un type qui a été défini dans un autre <em>crate</em>. Vous ne connaissez pas encore le fonctionnement des <em>crates</em>, mais pour vous pour l’instant, cela signifie que seuls les types que <em>vous</em> avez définis peuvent être implémentés dans votre code. Et définir un synonyme ne fonctionnera pas, puisque le compilateur les traite comme deux types identiques.</p>
<p>C’est là qu’intervient la structure-tuple à un seul champ : il s’agit d’un type différent, créé par vous, vous pouvez donc l’implémenter. Mais le compilateur n’est pas idiot, il se rend bien compte que c’est juste un emballage autour du type de départ, et il optimise tout cela, si bien qu’il n’y a pas de perte de temps à l’exécution (<em>overhead</em>, en anglais).</p>
<p>Pour notre type <code>CString</code>, voici les trois fonctions membres que l’on va créer.</p>
<pre class="code rust literal-block">
<span class="keyword">impl</span><span class="whitespace"> </span><span class="name">CString</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">new</span><span class="punctuation">(</span><span class="name">s</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword type">str</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="name">Self</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">string</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">s</span><span class="punctuation">.</span><span class="name">to_string</span><span class="punctuation">();</span><span class="whitespace">
        </span><span class="name">string</span><span class="punctuation">.</span><span class="name">push</span><span class="punctuation">(</span><span class="literal string char">'\0'</span><span class="punctuation">);</span><span class="whitespace">
        </span><span class="name">CString</span><span class="punctuation">(</span><span class="name">string</span><span class="punctuation">)</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">

    </span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">as_ptr</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name builtin pseudo">self</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword reserved">const</span><span class="whitespace"> </span><span class="name">c_char</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="name">CString</span><span class="punctuation">(</span><span class="keyword">ref</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name builtin pseudo">self</span><span class="punctuation">;</span><span class="whitespace">
        </span><span class="name">st</span><span class="punctuation">.</span><span class="name">as_ptr</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword reserved">const</span><span class="whitespace"> </span><span class="name">c_char</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">

    </span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">as_ref</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name builtin pseudo">self</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword type">str</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="name">CString</span><span class="punctuation">(</span><span class="keyword">ref</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name builtin pseudo">self</span><span class="punctuation">;</span><span class="whitespace">
        </span><span class="name">st</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>La fonction <code>new</code> ne devrait pas vous poser de problème, en revanche, vous devez vous demander ce qui se passe à la première ligne de chacune des deux autres fonctions. Il s’agit d’une liaison par <strong>déconstruction</strong>. Si vous avez l’habitude de la programmation fonctionnelle, vous devez être en terrain connu ; pour les autres, accrochez-vous !</p>
<p>On l’a vu, pour chaque type, il existe un constructeur natif fourni par la syntaxe de Rust. Lorsque ce type possède des champs, il est possible, lorsque l’on crée une liaison (à l’aide de <code>let</code>), de lier directement le contenu de ces champs à des identifiants, plutôt que de lier l’objet global.</p>
<p>Ainsi, si l’on prend le type <code>struct RGBA(u8, u8, u8, u8)</code> de tout à l’heure, on peut tout d’abord <strong>construire</strong> un objet de ce type et le lier à un identifiant, selon une syntaxe que vous connaissez.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">couleur</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">RGBA</span><span class="punctuation">(</span><span class="literal number hex">0xff</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="literal number hex">0x42</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="literal number hex">0x00</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="literal number hex">0x79</span><span class="punctuation">);</span>
</pre>
<p>Puis, plus tard dans le code, si on veut accéder aux champs de manière individuelle, on va pouvoir <strong>déconstruire</strong> cet objet, en utilisant le constructeur natif dans la partie gauche de la liaison, comme ceci.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">RGBA</span><span class="punctuation">(</span><span class="name">rouge</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">vert</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">bleu</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">trans</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">couleur</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;0x{:x} 0x{:x} 0x{:x} 0x{:x}&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">rouge</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">vert</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">bleu</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">trans</span><span class="punctuation">);</span>
</pre>
<p>C’est particulièrement utile, et cela fonctionne avec tous les constructeurs natifs, même si vous verrez très rarement le cas suivant.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">InputId</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">bustype</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">bus</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="name">vendor</span><span class="whitespace">  </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">vend</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="name">product</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">prod</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="name">version</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">vers</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">ii</span><span class="punctuation">;</span><span class="whitespace">

</span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;La version est {}.&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">vers</span><span class="punctuation">);</span>
</pre>
<p>Notez que si certains champs ne vous intéressent pas, comme avec toutes les liaisons, vous pouvez les jeter avec l’eau du bain en remplaçant leur identifiant par <code>_</code>, comme dans cet exemple.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">RGBA</span><span class="punctuation">(</span><span class="name">rouge</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">_</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">bleu</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">_</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">couleur</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;0x{:x} 0x{:x}&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">rouge</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">bleu</span><span class="punctuation">);</span>
</pre>
<p>Il y a cependant une difficulté : une liaison par déconstruction consume la donnée qui lui est fournie à droite, comme toutes les liaisons. Vous rencontrerez donc une erreur si vous essayez de déconstruire une référence, puisque vous allez essayer de prendre la propriété du contenu de ses champs, alors que vous n’avez pas la propriété de l’objet complet.</p>
<p>La solution, c’est de demander une référence vers la valeur contenue dans le champ, ce qui se fait à l’aide du mot-clé <code>ref</code>, comme dans cet exemple.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">couleur</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">RGBA</span><span class="punctuation">(</span><span class="literal number hex">0xff</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="literal number hex">0x42</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="literal number hex">0x00</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="literal number hex">0x79</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">ref_couleur</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="name">couleur</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">RGBA</span><span class="punctuation">(</span><span class="keyword">ref</span><span class="whitespace"> </span><span class="name">rouge</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">_</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="keyword">ref</span><span class="whitespace"> </span><span class="name">bleu</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">_</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="operator">*</span><span class="name">ref_couleur</span><span class="punctuation">;</span><span class="whitespace">
</span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;0x{:x} 0x{:x}&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">rouge</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">bleu</span><span class="punctuation">);</span>
</pre>
<p>Notez que lorsque vous déconstruisez une référence, vous pouvez au choix déréférencer le côté droit de la liaison (comme ici, avec <code>*ref_couleur</code>), ou intégrer dans le côté gauche le fait qu’il s’agit d’une référence (ici, on aurait <code>let &amp;RGBA(…) = ref_couleur;</code>.</p>
<div class="important">
<p class="first admonition-title"></p>
<p>Il est très important que vous compreniez la différence entre <code>&amp;</code> et <code>ref</code>.</p>
<ul class="last simple">
<li>Si un objet ou un champ est <em>déjà</em> une référence lorsque vous lancez la déconstruction, vous le signalez grâce à <code>&amp;</code>.</li>
<li>Si cet objet <em>n’est pas</em> une référence, mais que vous voulez associer l’identifiant avec une référence vers cet objet, alors vous utilisez <code>ref</code>.</li>
</ul>
</div>
<p>À présent, revenons-en aux deux fonctions membres du <code>CString</code>.</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">as_ptr</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name builtin pseudo">self</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword reserved">const</span><span class="whitespace"> </span><span class="name">c_char</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="name">CString</span><span class="punctuation">(</span><span class="keyword">ref</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name builtin pseudo">self</span><span class="punctuation">;</span><span class="whitespace">
    </span><span class="name">st</span><span class="punctuation">.</span><span class="name">as_ptr</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword reserved">const</span><span class="whitespace"> </span><span class="name">c_char</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">as_ref</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name builtin pseudo">self</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword type">str</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="name">CString</span><span class="punctuation">(</span><span class="keyword">ref</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name builtin pseudo">self</span><span class="punctuation">;</span><span class="whitespace">
    </span><span class="name">st</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Ici, <code>self</code> est une référence à un <code>CString</code>, que l’on déconstruit, afin d’obtenir une référence vers le <code>String</code> qu’il contient, et associer cette référence à l’identifiant <code>st</code>. On poursuit ensuite le traitement en utilisant <code>st</code>.</p>
<p>Quant aux lignes qui se trouvaient dans la fonction <code>main</code>…</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">st</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="literal string">&quot;/dev/input/event6&quot;</span><span class="punctuation">.</span><span class="name">to_string</span><span class="punctuation">();</span><span class="whitespace">
</span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">pt</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">to_c_string</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">fd</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="keyword">unsafe</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">open</span><span class="punctuation">(</span><span class="name">pt</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">O_RDONLY</span><span class="whitespace"> </span><span class="operator">|</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">O_NONBLOCK</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="punctuation">};</span><span class="whitespace">

</span><span class="keyword">if</span><span class="whitespace"> </span><span class="name">fd</span><span class="whitespace"> </span><span class="operator">&lt;</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">panic</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;Impossible d’ouvrir le fichier {}.&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>… elles deviennent dès lors ceci.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">name</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">CString</span><span class="operator">::</span><span class="name">new</span><span class="punctuation">(</span><span class="literal string">&quot;/dev/input/event6&quot;</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">fd</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="keyword">unsafe</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">libc</span><span class="operator">::</span><span class="name">open</span><span class="punctuation">(</span><span class="name">name</span><span class="punctuation">.</span><span class="name">as_ptr</span><span class="punctuation">(),</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">O_RDONLY</span><span class="whitespace"> </span><span class="operator">|</span><span class="whitespace"> </span><span class="name">libc</span><span class="operator">::</span><span class="name">O_NONBLOCK</span><span class="punctuation">)</span><span class="whitespace">
</span><span class="punctuation">};</span><span class="whitespace">

</span><span class="keyword">if</span><span class="whitespace"> </span><span class="name">fd</span><span class="whitespace"> </span><span class="operator">&lt;</span><span class="whitespace"> </span><span class="literal number integer">0</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">panic</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;Impossible d’ouvrir le fichier {}.&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">name</span><span class="punctuation">.</span><span class="name">as_ref</span><span class="punctuation">());</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Et la fonction <code>to_c_string</code> disparaît complètement.</p>
<div class="note">
<p class="first admonition-title"></p>
<p class="last">La bibliothèque standard de Rust définit deux types <code>CStr</code> et <code>CString</code> qui ont une fonction proche du type défini ici, mais ils sont beaucoup plus difficiles à utiliser, alors tant pis pour eux.</p>
</div>
<h1 id="decor-a-motifs">Décor à motifs</h1>
<p>À la fin du chapitre 3, on avait codé un passage très moche permettant de créer un vecteur de <code>EventType</code> à partir d’un champ de bits. Un passage qui ressemblait à ceci.</p>
<pre class="code rust literal-block">
<span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">bits</span><span class="whitespace"> </span><span class="operator">&gt;&gt;</span><span class="whitespace"> </span><span class="literal number hex">0x01</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">%</span><span class="whitespace"> </span><span class="literal number bin">0b10</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="literal number integer">1</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">event_types</span><span class="punctuation">.</span><span class="name">push</span><span class="punctuation">(</span><span class="name">EventType</span><span class="operator">::</span><span class="name">Key</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">
</span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">bits</span><span class="whitespace"> </span><span class="operator">&gt;&gt;</span><span class="whitespace"> </span><span class="literal number hex">0x02</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">%</span><span class="whitespace"> </span><span class="literal number bin">0b10</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="literal number integer">1</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">event_types</span><span class="punctuation">.</span><span class="name">push</span><span class="punctuation">(</span><span class="name">EventType</span><span class="operator">::</span><span class="name">Relative</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">
</span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">bits</span><span class="whitespace"> </span><span class="operator">&gt;&gt;</span><span class="whitespace"> </span><span class="literal number hex">0x03</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">%</span><span class="whitespace"> </span><span class="literal number bin">0b10</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="literal number integer">1</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">event_types</span><span class="punctuation">.</span><span class="name">push</span><span class="punctuation">(</span><span class="name">EventType</span><span class="operator">::</span><span class="name">Absolute</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Je vous avais alors dit qu’on apprendrait dans ce chapitre un moyen d’écrire ce code de manière plus propre. C’est ce à quoi nous allons nous atteler, en commençant par définir un constructeur personnalisé pour le type <code>EventType</code>. L’enveloppe de ce constructeur sera comme suit, ainsi que vous vous en doutez.</p>
<pre class="code rust literal-block">
<span class="keyword">impl</span><span class="whitespace"> </span><span class="name">EventType</span><span class="whitespace">  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">new</span><span class="punctuation">(</span><span class="name">int</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u8</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="name">Self</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="comment single">// Le code ici.
</span><span class="whitespace">    </span><span class="punctuation">}</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Un <code>u8</code> suffit, puisque la valeur maximale possible est <code>0x1f</code>. Mais à présent, avec les outils que vous connaissez, vous en êtes réduits à faire une grosse série de <code>if</code>-<code>else if</code>-<code>else</code>. Il est donc temps d’introduire le <strong>filtrage par motif</strong>. Là encore, ceux qui ont un bagage en programmation fonctionnelle seront à l’aise, et les autres vont devoir s’accrocher.</p>
<p>Le filtrage par motif consiste à prendre une valeur donnée, et à essayer de la lier par déconstruction à une série de constructeurs différents appelés <strong>motifs</strong>. Lorsque l’un de ces motifs correspond à la valeur entrée, une certaine <strong>branche</strong> du filtrage par motif est exécutée. Voici à quoi cela ressemble.</p>
<pre class="code rust literal-block">
<span class="keyword">match</span><span class="whitespace"> </span><span class="ajout">&lt;valeur&gt;</span><span class="whitespace">  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="ajout">&lt;motif 1&gt;</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="ajout">&lt;branche 1&gt;</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="ajout">&lt;motif 2&gt;</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="ajout">&lt;branche 2&gt;</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="ajout">&lt;motif 3&gt;</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="ajout">&lt;branche 3&gt;</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="ajout">&lt;motif 4&gt;</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="ajout">&lt;branche 4&gt;</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="error">…</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Il y a cependant un certain nombre de règles.</p>
<ul class="simple">
<li>Les motifs doivent tous être des constructeurs du même type, et du même type que la valeur qui va être comparée aux motifs.</li>
<li>Toutes les branches doivent renvoyer une valeur du même type. S’il y a plusieurs instructions dans une branche donnée, on les entoure d’accolades.</li>
<li>La valeur est comparée au premier motif, puis au deuxième, puis au troisième, et ainsi de suite.</li>
<li>Le filtrage doit être complet : tous les constructeurs d’un même type doivent être traités. Au besoin, le motif <code>_</code> permet de gérer tous les cas restants.</li>
</ul>
<p>Dans le cas d’un <code>u8</code>, les constructeurs sont <code>0</code>, <code>1</code>, etc. jusqu’à <code>255</code>. Voici donc le code complet de notre constructeur de <code>EventType</code>.</p>
<pre class="code rust literal-block">
<span class="keyword">impl</span><span class="whitespace"> </span><span class="name">EventType</span><span class="whitespace">  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">new</span><span class="punctuation">(</span><span class="name">int</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">u8</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="name">Self</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="keyword">match</span><span class="whitespace"> </span><span class="name">int</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
            </span><span class="literal number hex">0x00</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventType</span><span class="operator">::</span><span class="name">Synchro</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="literal number hex">0x01</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventType</span><span class="operator">::</span><span class="name">Key</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="literal number hex">0x02</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventType</span><span class="operator">::</span><span class="name">Relative</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="literal number hex">0x03</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventType</span><span class="operator">::</span><span class="name">Absolute</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="literal number hex">0x04</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventType</span><span class="operator">::</span><span class="name">Miscellaneous</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="literal number hex">0x05</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventType</span><span class="operator">::</span><span class="name">Switch</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="literal number hex">0x11</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventType</span><span class="operator">::</span><span class="name">LED</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="literal number hex">0x12</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventType</span><span class="operator">::</span><span class="name">Sound</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="literal number hex">0x14</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventType</span><span class="operator">::</span><span class="name">Repeat</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="literal number hex">0x15</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventType</span><span class="operator">::</span><span class="name">FF</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="literal number hex">0x16</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventType</span><span class="operator">::</span><span class="name">Power</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="literal number hex">0x17</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventType</span><span class="operator">::</span><span class="name">FFStatus</span><span class="punctuation">,</span><span class="whitespace">
            </span><span class="name">_</span><span class="whitespace">    </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">panic</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;EventType inconnu : 0x{:x}&quot;</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">int</span><span class="punctuation">)</span><span class="whitespace">
        </span><span class="punctuation">}</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Je le répète car c’est important : le filtrage par motifs fonctionne avec <em>tous</em> les constructeurs. Ainsi, cette fonction…</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">as_ptr</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name builtin pseudo">self</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword reserved">const</span><span class="whitespace"> </span><span class="name">c_char</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="name">CString</span><span class="punctuation">(</span><span class="keyword">ref</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name builtin pseudo">self</span><span class="punctuation">;</span><span class="whitespace">
    </span><span class="name">st</span><span class="punctuation">.</span><span class="name">as_ptr</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword reserved">const</span><span class="whitespace"> </span><span class="name">c_char</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>… pourrait également s’écrire ainsi.</p>
<pre class="code rust literal-block">
<span class="keyword">fn</span><span class="whitespace"> </span><span class="name">as_ptr</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name builtin pseudo">self</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword reserved">const</span><span class="whitespace"> </span><span class="name">c_char</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword">match</span><span class="whitespace"> </span><span class="operator">*</span><span class="name builtin pseudo">self</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="name">CString</span><span class="punctuation">(</span><span class="keyword">ref</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">st</span><span class="punctuation">.</span><span class="name">as_ptr</span><span class="punctuation">()</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword reserved">const</span><span class="whitespace"> </span><span class="name">c_char</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Revenons-en à notre fonction <code>main</code>. Le code qui crée le vecteur de <code>EventType</code> est celui-ci, pour rappel.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">event_types</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name builtin">Vec</span><span class="operator">::</span><span class="name">new</span><span class="punctuation">();</span><span class="whitespace">

</span><span class="name">event_types</span><span class="punctuation">.</span><span class="name">push</span><span class="punctuation">(</span><span class="name">EventType</span><span class="operator">::</span><span class="name">Synchro</span><span class="punctuation">);</span><span class="whitespace"> </span><span class="comment single">// Il doit nécessairement
</span><span class="whitespace">                                      </span><span class="comment single">// être présent.
</span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">bits</span><span class="whitespace"> </span><span class="operator">&gt;&gt;</span><span class="whitespace"> </span><span class="literal number hex">0x01</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">%</span><span class="whitespace"> </span><span class="literal number bin">0b10</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="literal number integer">1</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">event_types</span><span class="punctuation">.</span><span class="name">push</span><span class="punctuation">(</span><span class="name">EventType</span><span class="operator">::</span><span class="name">Key</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">
</span><span class="comment multiline">/* Les autres valeurs. */</span><span class="whitespace">
</span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">bits</span><span class="whitespace"> </span><span class="operator">&gt;&gt;</span><span class="whitespace"> </span><span class="literal number hex">0x17</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">%</span><span class="whitespace"> </span><span class="literal number bin">0b10</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="literal number integer">1</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="name">event_types</span><span class="punctuation">.</span><span class="name">push</span><span class="punctuation">(</span><span class="name">EventType</span><span class="operator">::</span><span class="name">FFStatus</span><span class="punctuation">);</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Avec le constructeur de <code>EventType</code> tout neuf, on pourrait remplacer <code>EventType::Key</code> et <code>EventType::FFStatus</code> par <code>EventType::new(0x01)</code> et <code>EventType::new(0x17)</code> respectivement, et pareil pour toutes les variables intermédiaires. Et là, votre âme de codeur C se dit que ce qui remplacerait élégamment cet amas de <code>if</code>, ce serait une boucle <code>for</code>.</p>
<p>Et vous avez raison. Il existe bien une boucle <code>for</code> en Rust, mais elle équivaut plutôt à une boucle <code>foreach</code> de Perl qu’à une boucle <code>for</code> de C. Voici sa syntaxe générale.</p>
<pre class="code rust literal-block">
<span class="keyword">for</span><span class="whitespace"> </span><span class="name">i</span><span class="whitespace"> </span><span class="keyword">in</span><span class="whitespace"> </span><span class="name">iterator</span><span class="whitespace">   </span><span class="punctuation">{</span><span class="whitespace">

</span><span class="punctuation">}</span>
</pre>
<p>La boucle va appliquer le même traitement à tous les éléments successifs d’un <strong>itérateur</strong>. On verra plus tard ce qu’est exactement un itérateur. Pour l’instant, vous allez juste découvrir le plus simple de tous les itérateurs : <code>&lt;n0&gt;..&lt;n&gt;</code>. Les objets <code>&lt;n0&gt;</code> et <code>&lt;n&gt;</code> sont des nombres entiers, de n’importe quel type, et l’itérateur énumère tous les entiers de <code>&lt;n0&gt;</code> à celui qui précède <code>&lt;n&gt;</code>.</p>
<p>Ainsi, <code>0x01..0x20</code> itère tous les entiers de <code>0x01</code> à <code>0x1f</code>. Ce qui permet de réduire le code initial à ceci.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">event_types</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name builtin">Vec</span><span class="operator">::</span><span class="name">new</span><span class="punctuation">();</span><span class="whitespace">

</span><span class="name">event_types</span><span class="punctuation">.</span><span class="name">push</span><span class="punctuation">(</span><span class="name">EventType</span><span class="operator">::</span><span class="name">Synchro</span><span class="punctuation">);</span><span class="whitespace"> </span><span class="comment single">// Il doit nécessairement
</span><span class="whitespace">                                      </span><span class="comment single">// être présent.
</span><span class="keyword">for</span><span class="whitespace"> </span><span class="name">i</span><span class="whitespace"> </span><span class="keyword">in</span><span class="whitespace"> </span><span class="literal number hex">0x01</span><span class="punctuation">..</span><span class="literal number hex">0x20</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">bits</span><span class="whitespace"> </span><span class="operator">&gt;&gt;</span><span class="whitespace"> </span><span class="name">i</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">%</span><span class="whitespace"> </span><span class="literal number bin">0b10</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="literal number integer">1</span><span class="whitespace">  </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="name">event_types</span><span class="punctuation">.</span><span class="name">push</span><span class="punctuation">(</span><span class="name">EventType</span><span class="operator">::</span><span class="name">new</span><span class="punctuation">(</span><span class="name">i</span><span class="punctuation">));</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Un gain plus qu’appréciable, donc ! C’est maintenant votre tour de coder. Vous allez réaliser la même opération d’assainissement sur toute la partie qui gère les codes d’événement. La solution est bien sûr juste en-dessous, pour quand vous aurez terminé de travailler.</p>
<p>Tout d’abord, le constructeur personnalisé.</p>
<pre class="code rust literal-block">
<span class="keyword">impl</span><span class="whitespace"> </span><span class="name">EventCode</span><span class="whitespace">  </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword">fn</span><span class="whitespace"> </span><span class="name">new</span><span class="punctuation">(</span><span class="name">event_type</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="name">EventType</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">int</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="keyword type">usize</span><span class="punctuation">)</span><span class="whitespace"> </span><span class="operator">-&gt;</span><span class="whitespace"> </span><span class="name">Self</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="keyword">match</span><span class="whitespace"> </span><span class="name">event_type</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
            </span><span class="name">EventType</span><span class="operator">::</span><span class="name">Key</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="keyword">match</span><span class="whitespace"> </span><span class="name">int</span><span class="whitespace"> </span><span class="punctuation">{</span><span class="whitespace">
                </span><span class="literal number hex">0x110</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventCode</span><span class="operator">::</span><span class="name">ButtonLeft</span><span class="punctuation">,</span><span class="whitespace">
                </span><span class="literal number hex">0x111</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventCode</span><span class="operator">::</span><span class="name">ButtonRight</span><span class="punctuation">,</span><span class="whitespace">
                </span><span class="literal number hex">0x112</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventCode</span><span class="operator">::</span><span class="name">ButtonMiddle</span><span class="punctuation">,</span><span class="whitespace">
                </span><span class="literal number hex">0x113</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventCode</span><span class="operator">::</span><span class="name">ButtonSide</span><span class="punctuation">,</span><span class="whitespace">
                </span><span class="literal number hex">0x114</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventCode</span><span class="operator">::</span><span class="name">ButtonExtra</span><span class="punctuation">,</span><span class="whitespace">
                </span><span class="literal number hex">0x115</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventCode</span><span class="operator">::</span><span class="name">ButtonForward</span><span class="punctuation">,</span><span class="whitespace">
                </span><span class="literal number hex">0x116</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventCode</span><span class="operator">::</span><span class="name">ButtonBack</span><span class="punctuation">,</span><span class="whitespace">
                </span><span class="literal number hex">0x117</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">EventCode</span><span class="operator">::</span><span class="name">ButtonTask</span><span class="punctuation">,</span><span class="whitespace">
                </span><span class="name">_</span><span class="whitespace">     </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">unimplemented</span><span class="operator">!</span><span class="punctuation">()</span><span class="whitespace">
            </span><span class="punctuation">},</span><span class="whitespace">
            </span><span class="name">_</span><span class="whitespace"> </span><span class="operator">=&gt;</span><span class="whitespace"> </span><span class="name">unimplemented</span><span class="operator">!</span><span class="punctuation">()</span><span class="whitespace">
        </span><span class="punctuation">}</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
</span><span class="punctuation">}</span>
</pre>
<p>Et ensuite, le code dans la fonction <code>main</code>, avec l’appel à l’IOCTL et l’affichage après coup, pour le contexte.</p>
<pre class="code rust literal-block">
<span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">key_bits</span><span class="whitespace"> </span><span class="operator">:</span><span class="whitespace"> </span><span class="punctuation">[</span><span class="name">c_ulong</span><span class="punctuation">;</span><span class="whitespace"> </span><span class="literal number integer">12</span><span class="punctuation">]</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="punctuation">[</span><span class="literal number integer">0</span><span class="punctuation">;</span><span class="whitespace"> </span><span class="literal number integer">12</span><span class="punctuation">];</span><span class="whitespace">

</span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">_</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">ioctl</span><span class="punctuation">(</span><span class="name">fd</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">IOCTL</span><span class="operator">::</span><span class="name">GetKeyBits</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="operator">&amp;</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">key_bits</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">_</span><span class="whitespace"> </span><span class="keyword">as</span><span class="whitespace"> </span><span class="operator">*</span><span class="keyword">mut</span><span class="whitespace"> </span><span class="keyword type">u8</span><span class="punctuation">);</span><span class="whitespace">

</span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="keyword">mut</span><span class="whitespace"> </span><span class="name">event_codes</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name builtin">Vec</span><span class="operator">::</span><span class="name">new</span><span class="punctuation">();</span><span class="whitespace">

</span><span class="keyword">for</span><span class="whitespace"> </span><span class="name">i</span><span class="whitespace"> </span><span class="keyword">in</span><span class="whitespace"> </span><span class="literal number hex">0x00</span><span class="punctuation">..</span><span class="literal number hex">0x300</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
    </span><span class="keyword declaration">let</span><span class="whitespace"> </span><span class="name">a</span><span class="whitespace"> </span><span class="operator">=</span><span class="whitespace"> </span><span class="name">i</span><span class="whitespace"> </span><span class="operator">/</span><span class="whitespace"> </span><span class="literal number integer">64</span><span class="punctuation">;</span><span class="whitespace">
    </span><span class="keyword">if</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">key_bits</span><span class="punctuation">[</span><span class="name">a</span><span class="punctuation">]</span><span class="whitespace"> </span><span class="operator">&gt;&gt;</span><span class="whitespace"> </span><span class="punctuation">(</span><span class="name">i</span><span class="whitespace"> </span><span class="operator">-</span><span class="whitespace"> </span><span class="literal number integer">64</span><span class="whitespace"> </span><span class="operator">*</span><span class="whitespace"> </span><span class="name">a</span><span class="punctuation">))</span><span class="whitespace"> </span><span class="operator">%</span><span class="whitespace"> </span><span class="literal number bin">0b10</span><span class="whitespace"> </span><span class="operator">==</span><span class="whitespace"> </span><span class="literal number integer">1</span><span class="whitespace">    </span><span class="punctuation">{</span><span class="whitespace">
        </span><span class="name">event_codes</span><span class="punctuation">.</span><span class="name">push</span><span class="punctuation">(</span><span class="name">EventCode</span><span class="operator">::</span><span class="name">new</span><span class="punctuation">(</span><span class="name">EventType</span><span class="operator">::</span><span class="name">Key</span><span class="punctuation">,</span><span class="whitespace"> </span><span class="name">i</span><span class="punctuation">));</span><span class="whitespace">
    </span><span class="punctuation">}</span><span class="whitespace">
</span><span class="punctuation">}</span><span class="whitespace">

</span><span class="name">println</span><span class="operator">!</span><span class="punctuation">(</span><span class="literal string">&quot;libevdev_has_event_code(dev, EV_KEY, BTN_LEFT) = {}&quot;</span><span class="punctuation">,</span><span class="whitespace">
    </span><span class="name">event_codes</span><span class="punctuation">.</span><span class="name">contains</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name">EventCode</span><span class="operator">::</span><span class="name">ButtonLeft</span><span class="punctuation">));</span>
</pre>
<p>Notez que <code>a</code> étant utilisé comme indice d’un tableau, il est obligatoirement de type <code>usize</code>, ce qui a pour conséquence que <code>i</code> est aussi un <code>usize</code> à cause de <code>let a = i / 64;</code>. C’est pourquoi, par facilité, on a défini le constructeur de <code>EventCode</code> comme prenant un <code>usize</code> en argument.</p>
<hr class="docutils" />
<p>C’est ici que s’achève ce quatrième chapitre. Tâchez de bien comprendre comment fonctionne le filtrage par motifs avant de continuer. En effet, il vous apparaît sans doute pour l’instant comme un simple confort d’écriture : c’est parce que nous n’avons encore vu que les énumérations <em>simples</em>. Lorsque nous aurons vu les autres sortes d’énumérations, vous comprendrez pourquoi le filtrage par motifs est aussi utilisé en Rust.</p>
<p>Et parce qu’il fallait bien que cela arrive un jour, je vous laisse un exercice à réaliser avant de passer au chapitre 5. Votre mission : créer un type <code>Device</code> qui représente notre périphérique, avec un constructeur, et toutes les fonctions membres nécessaires pour laisser le moins de code possible dans <code>main</code>, à l’exception des affichages.</p>
<p>La correction au prochain chapitre !</p>
